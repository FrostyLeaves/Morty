#include "inner_constant.hlsl"
#include "inner_functional.hlsl"
#include "model_struct.hlsl"

struct VS_IN
{
    float3 pos : POSITION;

#if SKELETON_ENABLE == 1
    int bonesID[MBONES_PER_VERTEX] : BONES_ID;
    float bonesWeight[MBONES_PER_VERTEX] : BONES_WEIGHT;
#endif

    float3 normal : NORMAL;
    float3 tangent : TANGENT;
    float3 bitangent : BITANGENT;
    float2 uv : TEXCOORDS;
};

struct VS_OUT
{
    float4 pos : SV_POSITION;
    float2 uv : TEXCOORD;
    float depth : DEPTH;
    
    float3 normal : NORMAL;
    float3 tangent : Tangent;
    float3 bitangent : BITANGENT;

    float3 worldPos : WORLD_POS;
};

VS_OUT VS_MAIN(VS_IN input, uint INSTANCE_ID : SV_InstanceID)
{
    VS_OUT output;

    output.uv.x = input.uv.x;
    output.uv.y = input.uv.y;


#if SKELETON_ENABLE == 1

    float4x4 matBoneTransform = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
    float fWeight = 1.0f;
    for (int i = 0; i < MBONES_PER_VERTEX; ++i)
    {
        matBoneTransform += u_vBonesMatrix[input.bonesID[i]] * input.bonesWeight[i];
        fWeight = fWeight - input.bonesWeight[i];
    }
    matBoneTransform += float4x4(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1) * fWeight;

    float4 posFromBones = mul(float4(input.pos, 1.0f), matBoneTransform);
    output.pos = mul(posFromBones, mul(MESH_WORLD_MATRIX, u_matCamProj));
    output.worldPos = mul(posFromBones, MESH_WORLD_MATRIX).xyz;

#else

    float4 f4WorldPosition = mul(float4(input.pos, 1.0f), MESH_WORLD_MATRIX);
    
    output.pos = mul(f4WorldPosition, u_matCamProj);
    output.worldPos = f4WorldPosition.xyz;

#endif

    output.depth = output.pos.z;

    output.normal = normalize(mul(input.normal, MESH_NORMAL_MATRIX));
    output.tangent = normalize(mul(input.tangent, MESH_NORMAL_MATRIX));
    output.bitangent = normalize(cross(output.tangent, output.normal));

    return output;
}
