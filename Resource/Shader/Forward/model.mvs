#include "../Forward/light_forward.hlsl"

VS_OUT VS_MAIN(VS_IN input, uint INSTANCE_ID : SV_InstanceID)
{
    VS_OUT output;


    float4 vertexPos = getModelVertexPosition(input, INSTANCE_ID);
    float4 worldPos = mul(vertexPos, MESH_WORLD_MATRIX);
    
    output.worldPos = worldPos.xyz;
    output.pos = mul(worldPos, u_matCamProj);
    output.uv = input.uv;


#if MCALC_NORMAL_IN_VS

    float3 f3ToCameraDir = normalize(u_f3CameraPosition - output.worldPos);

    float3 T = mul(input.tangent, MESH_NORMAL_MATRIX);
    float3 N = mul(input.normal, MESH_NORMAL_MATRIX);
    float3 B = cross(T, N);
    float3x3 TBN = float3x3(T,B,N);
    TBN = transpose(TBN);//正交矩阵的转置矩阵==逆矩阵

    output.dirLightDirTangentSpace = normalize(mul(u_xDirectionalLight.f3LightDir , TBN));
    output.toCameraDirTangentSpace = normalize(mul(f3ToCameraDir, TBN));

    for(int pointIdx = 0; pointIdx < MPOINT_LIGHT_MAX_NUMBER; ++pointIdx)
    {
        float3 f3PointLightDir = u_vPointLights[pointIdx].f3WorldPosition - output.worldPos;
        output.pointLightDirTangentSpace[pointIdx] = normalize(mul(f3PointLightDir, TBN));
    }

    output.normal = normalize(mul(input.normal, MESH_NORMAL_MATRIX));
#else

    output.normal = normalize(mul(input.normal, MESH_NORMAL_MATRIX));
    output.tangent = normalize(mul(input.tangent, MESH_NORMAL_MATRIX));
    output.bitangent = normalize(cross(output.tangent, output.normal));

#endif

    output.vertexPointLight = float3(0, 0, 0);

    for(int pixelPointIdx = MPOINT_LIGHT_PIXEL_NUMBER; pixelPointIdx < min(MPOINT_LIGHT_MAX_NUMBER, u_nValidPointLightsNumber); ++pixelPointIdx)
    {
        float3 f3CameraDir = normalize(u_f3CameraPosition - output.worldPos);
        float3 f3LightDir = normalize(u_vPointLights[pixelPointIdx].f3WorldPosition - output.worldPos);
        float4 f3AmbiColor = u_texDiffuse.SampleLevel(LinearSampler, input.uv, 0);
        float4 f3DiffColor = f3AmbiColor;
        float4 f3SpecColor = f3AmbiColor;//u_texSpecular.Sample(LinearSampler, input.uv);
        output.vertexPointLight += AdditionPointLight(u_vPointLights[pixelPointIdx], f3CameraDir, f3LightDir, output.normal, output.worldPos, f3DiffColor.xyz, f3SpecColor.xyz);
    }
    

    return output;
}
