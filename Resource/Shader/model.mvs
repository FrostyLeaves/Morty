#include "light_forward.hlsl"

struct VS_IN
{
    float3 pos : POSITION;
    float3 normal : NORMAL;
    float3 tangent : TANGENT;
    float3 bitangent : BITANGENT;
    float2 uv : TEXCOORDS;
    
#if SKELETON_ENABLE == 1
    int bonesID[MBONES_PER_VERTEX] : BONES_ID;
    float bonesWeight[MBONES_PER_VERTEX] : BONES_WEIGHT;
#endif

};


VS_OUT VS_MAIN(VS_IN input, uint INSTANCE_ID : SV_InstanceID)
{
    VS_OUT output;

    output.uv.x = input.uv.x;
    output.uv.y = input.uv.y;


#if SKELETON_ENABLE == 1

    float4x4 matBoneTransform = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
    float fWeight = 1.0f;
    for (int i = 0; i < MBONES_PER_VERTEX; ++i)
    {
        matBoneTransform += u_vBonesMatrix[input.bonesID[i]] * input.bonesWeight[i];
        fWeight = fWeight - input.bonesWeight[i];
    }
    matBoneTransform += float4x4(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1) * fWeight;

    float4 posFromBones = mul(float4(input.pos, 1.0f), matBoneTransform);
    output.pos = mul(posFromBones, mul(MESH_WORLD_MATRIX, u_matCamProj));

    output.worldPos = mul(  mul(input.pos, (float3x3)(matBoneTransform)),   (float3x3)(MESH_WORLD_MATRIX));
#else
    
    output.worldPos = mul(float4(input.pos, 1.0f), MESH_WORLD_MATRIX).xyz;
    output.pos = mul(float4(input.pos, 1.0f), mul(MESH_WORLD_MATRIX, u_matCamProj));

#endif

#if MCALC_NORMAL_IN_VS

    float3 f3ToCameraDir = normalize(u_f3CameraPosition - output.worldPos);

    float3 T = mul(input.tangent, MESH_NORMAL_MATRIX);
    float3 N = mul(input.normal, MESH_NORMAL_MATRIX);
    float3 B = cross(T, N);
    float3x3 TBN = float3x3(T,B,N);
    TBN = transpose(TBN);//正交矩阵的转置矩阵==逆矩阵

    output.dirLightDirTangentSpace = normalize(mul(u_f3DirectionLight , TBN));
    output.toCameraDirTangentSpace = normalize(mul(f3ToCameraDir, TBN));

    for(int pointIdx = 0; pointIdx < MPOINT_LIGHT_MAX_NUMBER; ++pointIdx)
    {
        float3 f3PointLightDir = u_vPointLights[pointIdx].f3WorldPosition - output.worldPos;
        output.pointLightDirTangentSpace[pointIdx] = normalize(mul(f3PointLightDir, TBN));
    }

    output.normal = normalize(mul(input.normal, MESH_NORMAL_MATRIX));
#else

    output.normal = normalize(mul(input.normal, MESH_NORMAL_MATRIX));
    output.tangent = normalize(mul(input.tangent, MESH_NORMAL_MATRIX));
    output.bitangent = normalize(cross(output.tangent, output.normal));

#endif

    output.vertexPointLight = float3(0, 0, 0);

    for(int pixelPointIdx = MPOINT_LIGHT_PIXEL_NUMBER; pixelPointIdx < min(MPOINT_LIGHT_MAX_NUMBER, u_nValidPointLightsNumber); ++pixelPointIdx)
    {
        float3 f3CameraDir = normalize(u_f3CameraPosition - output.worldPos);
        float3 f3LightDir = normalize(u_vPointLights[pixelPointIdx].f3WorldPosition - output.worldPos);
        float4 f3AmbiColor = u_texDiffuse.SampleLevel(LinearSampler, input.uv, 0);
        float4 f3DiffColor = f3AmbiColor;
        float4 f3SpecColor = f3AmbiColor;//u_texSpecular.Sample(LinearSampler, input.uv);
        output.vertexPointLight += AdditionPointLight(u_vPointLights[pixelPointIdx], f3CameraDir, f3LightDir, output.normal, output.worldPos, f3DiffColor.xyz, f3SpecColor.xyz);
    }


    return output;
}
